Generator函数是ES6提供的异步编程的解决方案，语法上，Generator是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，可以依次遍历Generator函数内部的每一个状态

## 1.特性

·`function`关键字与函数名之间有一个星号

内部通过`yield`表达式，定义不同的内部状态

返回的遍历器对象，使用`next()`方法依次遍历函数内部的状态

## 2.yield表达式

`Generator`函数内部通过`yield`表达式来暂停执行后面的操作，只有通过`next()`方法才能继续往下执行

- next方法的运行逻辑：
  - 遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值
  - 再次调用`next`方法，就继续往下执行，直到遇到下一个`yield`表达式，就暂停执行并将后面的值赋给`value`返回
  - 如果没有遇到新的`yield`表达式，就一直运行到函数结束，将`return`语句后面的表达式作为对象的`value`值返回，如果没有`return`语句，则返回`undefined`

## 3.与Iterator的关系

`Generator`函数就是遍历器的生成函数，可以把`Generator`赋值给对象的`Symbol.Iterator`属性，从而使得该对象可以被`Iterator`接口相关的语句遍历

```js
const obj = {}
obj[Symbol.iterator] = function * () {
    yield 1;
    yield 2;
    yield 3;
}

[...obj]

for(const i of obj) {
    console.log(i)
}
```

## 4. next方法参数

`yield`表达式本身没有返回值，或者说返回值是`undefined`。`next`方法可以带一个参数，该参数就会被当作`上一个yield表达式的返回值`

```js
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```

上面代码中，第二次运行`next`方法的时候不带参数，导致 `y` 的值等于`2 * undefined`（即`NaN`），除以 `3` 以后还是`NaN`，因此返回对象的`value`属性也等于`NaN`。第三次运行`next`方法的时候不带参数，所以`z`等于`undefined`，返回对象的`value`属性等于`5 + NaN + undefined`，即`NaN`。

如果向`next`方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的`next`方法时，返回`x+1`的值`6`；第二次调用`next`方法，将上一次`yield`表达式的值设为`12`，因此`y`等于`24`，返回`y / 3`的值`8`；第三次调用`next`方法，将上一次`yield`表达式的值设为`13`，因此`z`等于`13`，这时`x`等于`5`，`y`等于`24`，所以`return`语句的值等于`42`。

## 5.next() throw() return()

- 都是让Generator函数恢复执行，并且使用不同的语句替换`yield`表达式

- `next()`是将上一个`yield`表达式替换成一个值

  ```js
  const g = function* (x, y) {
    let result = yield x + y;
    return result;
  };
  
  const gen = g(1, 2);
  gen.next(); // Object {value: 3, done: false}
  
  gen.next(1); // Object {value: 1, done: true}
  // 相当于将 let result = yield x + y
  // 替换成 let result = 1;
  ```

- `throw()`是将`yield`表达式替换成一个`throw`语句

  ```js
  gen.throw(new Error('出错了')); // Uncaught Error: 出错了
  // 相当于将 let result = yield x + y
  // 替换成 let result = throw(new Error('出错了'));
  ```

- `return()`相当于将`yield`表达式替换成一个`return`语句

  ```js
  gen.return(2); // Object {value: 2, done: true}
  // 相当于将 let result = yield x + y
  // 替换成 let result = return 2;
  ```



## 6.yield*

`yield*`表达式用来在一个Generator函数里面执行另一个Generator函数

```js
function * foo() {
    yield 'a';
    yield 'b'
}

function * bar() {
    yield 'x';
    yield foo();
    yield 'y'
}

for(let item of bar()) {
    console.log(item) // x a b y
}
```

- 任何数据结构只要有`iterator`接口，就能被`yield*`遍历

  ```js
  function * gen() {
      yield * [1,2,3]
  }
  
  gen().next()
  ```

