## 1.作用域

> 在JavaScript中，变量的可访问性由作用域管理。作用域由函数或代码块创建。变量只能在定义它的函数或代码块内使用。超出范围则不可访问

### 变量隔离

> 我们可以把作用域理解为一种空间策略，每个函数拥有自己的私有作用域，它对变量进行了隔离，控制了变量的可访问性，因此不同的作用域可以具有相同名称的变量而不冲突。

### 作用域嵌套

> 我们可以把`innerFunc()`嵌套在外部函数`outerFunc()`中，外部作用域中的`outerVar`变量在内部作用域中是可访问的。

### 小结

1. 作用域可以嵌套
2. 外部作用域的变量可以在内部作用域内部访问
3. 如果外部作用域中也找不到，最终会去全局作用域中查找，从内至外层层查找形成`作用域链`

**扩展：** 我们把内部作用域可以访问到外部作用域，而外部无法访问内部的行为叫做`作用域继承`，可以把全局作用域比喻成一个大房子，里面有很多层小房间（函数作用域或者块作用域），各自拥有自己的钥匙🔑。可以从里面访问外面，但是无法从外面访问里面，并且相互之间无法访问

## 2.闭包

示例：

```js
function outerFunc() {
  let outerVar = 'I am outside!';

  function innerFunc() {
    console.log(outerVar); // "I am outside!"
  }

  innerFunc();
}

outerFunc();
```

现在我们知道在`innerFunc()`作用域内可以从词法作用域访问变量`outerVar`，这里`innerFunc()`调用发生在其词法作用域（`outerFunc()`的作用域）内。

把`innerFunc()`修改到其词法作用域之外（`outerFunc()`之外）调用。`innerFunc()`还能访问`outerVar`吗？

让我们对代码片段进行调整：

```js
function outerFunc() {
  let outerVar = 'I am outside!';

  function innerFunc() {
    console.log(outerVar); // "I am outside!"
  }

  return innerFunc;
}

const myInnerFunc = outerFunc();
myInnerFunc();
```

现在`innerFunc()`在其词法作用域之外执行，但是`innerFunc()`仍然可以从其词法作用域访问`outerVar`，即使是在词法作用域之外执行。也就是说`innerFunc()`从其词法作用域捕获(又称记忆）变量`outerVar`。

换句话说，`innerFunc()`是一个闭包，因为它在词法作用域内捕获了变量`outerVar`。

正常来说，当`outerFunc`函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却很神奇的将`outerFunc`的作用域存活了下来，`innerFunc`依然持有该作用域的引用，这个引用就是闭包。

闭包是一个函数，它从定义它的地方记住变量，形成一个私有的作用域，保护里边的私有变量不受外界的干扰，除了保护私有变量外，还可以存储一些内容，而不管它以后在哪里执行，所以无论通过哪种方式将内部的函数传递到所在的词法作用域以外，它都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。

### 小结

某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数极限访问定义时的词法作用域。

**扩展**：通俗地讲闭包就是在一个函数里边再定义一个函数。这个内部函数一直保持有对外部函数中作用域的访问权限(小房间一直可以有大房子的访问权限)。

## 3.闭包的作用

1. 访问其他函数内部变量
2. 保护变量不被内存回收机制回收
3. 避免全局变量被污染 方便调用上下文的局部变量 加强封装性

## 4.总结

作用域决定了JavaScript中变量的可访问性。主要包括函数作用域和块作用域。

词法作用域允许函数作用域从外部作用域静态访问变量。

最后，闭包是从其词法作用域捕获变量的函数。用简单的话来说，闭包会记住从定义它的地方开始的变量，无论它在哪里执行。

闭包捕获事件处理程序，回调中的变量。它们用于函数式编程。