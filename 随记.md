## 1.鼠标滚轮事件`wheel`
在鼠标滚轮滚动时触发，可以用来判断页面是向上滚动还是向下滚动
```ts
useEffect(() => {
    const DOMMouseScroll = (e: WheelEvent) => {
      // 滚轮事件中的deltaY属性可以用来判断滚轮是向上滚动还是向下滚动
      const log: string = e.deltaY > 0 ? '向下滚动' : '向上滚动'
      console.log(log);
    };
    window.addEventListener('wheel', DOMMouseScroll);
    return () => removeEventListener('wheel', DOMMouseScroll);
})
```
## 2. cross-env
cross-env用于配置多个开发环境
- 安装
```bash
yarn add cross-env --dev
```
- 使用
```ts
"scripts": {
  "start": "cross-env PORT=8080 nodemon ./bin/www",
  "start:test": "cross-env PORT=8080 API_ENV=dev nodemon ./bin/www"
}
```
- 导入配置的变量
```ts
const PORT: string = process.env.PORT
const API_ENV: string = process.env.API_ENV;
```

## 3. export和export default的区别
- 导出方式

export可以先定义再导出，也可以在导出时再定义变量

export在一个模块中可以出现多次

***

export default是模块的默认导出方式，只能导出已经定义好的变量

export default在模块中只能出现一次

- 导入方式

export导出的对象，可以使用解构的方式进行导入
```ts
import { a, b } from 'aaa';
```

export default导出的对象，要使用变量名的方式导入
```ts
import '变量名' from 'aaa';
```
## 4.exports和module.exports的区别

区别在于导出方式的不同，exports导出的是模块函数，module.exports导出的是一个对象

- 导出
```js
const API_ENV = process.env.API_ENV;

const PORT = process.env.PORT;

exports.PORT = PORT;
exports.API_ENV = API_ENV;

module.exports = {
  PORT,
  API_ENV,
}
```
- 导入
```js
const { PORT, API_ENV } = require('../config.js');
```
## 5.git pull冲突问题解决
### 合并修改
```bash
git stash #封存修改
git pull origin master 
git stash pop #把修改还原
```
注：
- git stash：备份当前工作区内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前工作区内容保存到Git栈中
- git pull：拉取服务器上当前分支代码
- git stash pop：从Git栈中读取最近一次保存的内容，恢复工作区相关内容。同时，用户可能进行多次stash操作，需要保证后stash的最先被取到，所以用栈（先进后出）来管理；pop取栈顶的内容并恢复
- git stash list：显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。
- git stash clear：清空Git栈
### 放弃本次修改(不建议使用)
```bash
git reset --hard 
git pull origin master
```
## 6.CSS文本省略
- 单行文本省略
```css
width: 200px;
display: block;
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
```
- 多行文本省略
```css
width: 100px;
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
overflow: hidden;
```

## 7.git无法切换到刚创建的远程分支
```
git fetch --all
git reset --hard origin/master
git fetch
```

## 8.JavaScript几个特殊运算符的用法
**注：JavaScript中`null，undefined，false，""，NaN`都会被判定为false**
- `||`和`??`的区别

`||`和`??`主要用于默认值的赋值
```javascript
// || 运算符
const vaule = a || b; // 当左侧为 null，undefined，""，false，NaN时，右侧的值会生效

// ?? 运算符
const value = a ?? b; // 当且仅当左侧的值为 null 或 undefined时，右侧的值才会生效
```

- `&&`运算符

`&&`运算符一般用于短路判断，也可用于默认值的赋值
```javascript
a && b; // 当且仅当 a的判断值为true时，才会执行b语句

const value = a && b; // 当且仅当 a的判断值为true时，才会将b赋值给value，否则将a赋值给value
```

- `!!`运算符

`!!`运算符可以将值快速转换为它对应的判断值，可以在需要返回布尔值的数据遍历函数中使用(filter some find findIndex 等)
```javascript
const a = null;
console.log(!!a); // 输出 false
```

## 9.connect-multiparty
- 可以用于express编写框架上传文件接口
```js
const express = require('express');
const multipart = require('connect-multiparty');
const path = require('path');
const Oss = require('ali-oss');
const fs = require('fs');

const app = express();
app.use(express.json());

const multipartMiddleware = multipart({
  uploadDir: path.resolve(__dirname, 'static')
});

const client = new Oss({
  endpoint: 'You endpint',
  accessKeyId: 'You AccessKeyId',
  accessKeySecret: 'You AccessKeySecret',
  bucket: 'You Bucket'
});

app.post('/test', multipartMiddleware, async (req, res) => {
  const file = Object.values(req.files)[0];
  console.log(file);
  try {
    const result = await client.put(`express-test/${file.name}`, file.path);
    res.send(result.url);
  } catch (error) {
    res.send(error);
    throw error;
  } finally {
    fs.unlinkSync(file.path);
  };
});

app.listen(3000, () => console.log('http//127.0.0.1:3000'));
```

## 10.midway.js上传图片接口demo

- 具体可以参考egg官网的上传图片demo
 
- 下载`egg-oss`
- 如果采用`Stream`模式上传文件，还需要下载`stream-wormhole`依赖
```typescript
import { Controller, Post, Provide, Inject } from '@midwayjs/decorator';
import { Context } from 'egg';
import * as path from 'path';
const sendToWormhole = require('stream-wormhole');

@Provide()
@Controller()
export class ClientController {
  @Inject()
  ctx: Context;

  /**
   * file方式图片上传
   *
   */
  @Post('/test/file')
  async testClient() {
    const file = this.ctx.request.files[0];
    const name = `egg-multipart-test/${path.basename(file.filename)}`;

    let result: any;
    try {
      result = await this.ctx.oss.put(name, file.filepath);
    } catch (error) {
      return Promise.reject(error);
    } finally {
      fs.unlinkSync(file.filepath);
    }

    return {
      code: 200,
      message: '图片上传成功',
      data: result.url,
    };
  }

  /**
   * Stream方式图片上传
   *
   */
  @Post('/test/file')
  async testClient() {
    const stream = await this.ctx.getFileStream();
    const name = 'egg-multipart-test/' + path.basename(stream.filename);
    let result;
    try {
      result = await this.ctx.oss.putStream(name, stream);
    } catch (err) {
      await sendToWormhole(stream);
      throw new Error(err);
    }
    return {
      code: 200,
      message: '图片上传成功',
      data: result.url,
    };
  }
}

```

## 11.React对props.children的操作
- children类似与Vue中的插槽语法，但会比后者灵活得多，在TypeScript中，children的类型一般被定义为`React.ReactNode | React.ReactNode[]`
- React提供了相应的Api来操作children

```
{
  React.Children.map(props.children, (childItem, index) => (
    <>
      {childItem}
      {index !== props.children.length - 1 && <Divider type="vertical" />}
    </>
  ))
}
```
```
{React.Children.map(props.children, (childItem, i) => {
  if (i < 1) return
  return child
})}
```

## 12.BigInt
- BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库
- 创建 bigint 的方式有两种：在一个整数字面量后面加 n 或者调用 BigInt 函数，该函数从字符串、数字等中生成 bigint。
```js
const bigint = 1234567890123456789012345678901234567890n;
// or
const sameBigint = BigInt("1234567890123456789012345678901234567890");
```
### 运算
- `BigInt`大多数情况下可以像常规数字类型一样使用，计算后的返回值也是`BigInt`
```js
alert(1n + 2n); // 3
alert(5n / 2n); // 2
```
- `BigInt`不能和`number`类型混用
```js
alert(1n + 2); // Error: Cannot mix BigInt and other types
```

## 13.qs axios paramsSerializer

- axios在发起get请求时如果遇到数组可以使用`paramsSerializer`和`qs`进行参数的序列化
- 可以通过`yarn add qs`进行安装qs依赖包
```
axios.get(url, {
  params,
  paramsSerializer: (params) => {
      return qs.stringify(params, {arrayFormat: 'repeat'})
  }
})
```
- 其他示例
```
//形式： ids=1&ids=2&id=3
qs.stringify({ids: [1, 2, 3]}, { indices: false })
//形式： ids[0]=1&aids1]=2&ids[2]=3
qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘indices‘})
//形式：ids[]=1&ids[]=2&ids[]=3
qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘brackets‘})
//形式： ids=1&ids=2&id=3
qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘repeat‘}) 
```

## 14.滚动加载相关业务
- 三要素： scrollHeight scrollTop innerHeight和底部的高度
```js
useEffect(() => {
    const scroll = () => {
      const scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop, window.scrollY);
      const scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
      // 判断滚动条是否接触底部
      if (scrollHeight - window.innerHeight - scrollTop < 294) {
        setAnchorAffix({
          affix: true,
          top: anchorAffix.affix ? anchorAffix.top : (scrollTop - 35), // 144 是顶部菜单栏的高度
        });
      } else {
        setAnchorAffix({
          affix: false,
          top: 0,
        });
      }
      // 判断右侧菜单是否开启固定定位
      if (scrollTop) {
        setIsFixed(!anchorAffix.affix);
        setOffsetLeft(getOffsetLeft());
      } else {
        setIsFixed(false);
      }
    };
    window.addEventListener('scroll', scroll);
    return () => { window.removeEventListener('scroll', scroll); };
  }, [anchorAffix.affix]);
```

## 15.a链接下载导出文件
- a链接的download属性可以指定下载的文件名，仅在同源策略下有效
```js
const blob = await fetch(Object.values(res?.data)?.[0] as string).then(res => res.blob())
const aDownLoad = document.createElement('a');
const downLoadUrl = window.URL.createObjectURL(blob); // 将下载到的文件使用createObjectURL实例化成临时的url
aDownLoad.href = downLoadUrl
aDownLoad.download = "name";
aDownLoad.click();
window.URL.revokeObjectURL(downLoadUrl); // 下载完毕时清除临时的url
```

## 16.倒计时
```js
import React, { useState, useEffect, useRef } from 'react';
import { Button } from 'antd';

export default () => {
  const [text, setText] = useState('获取验证码');

  const timerRef = useRef<number>();

  const handleClick = () => {
    timerRef.current && clearInterval(timerRef.current);
    let time = 10;
    timerRef.current = window.setInterval(() => {
      if (time === 0) {
        clearInterval(timerRef.current);
        timerRef.current = undefined;
        setText('重新获取验证码');
        time = 10;
      } else {
        time -= 1;
        setText(`${time}后重新获取`)
      }
    }, 1000);
  }

  return (
    <div>
      <Button onClick={handleClick} disabled={!!timerRef.current}>{text}</Button>
    </div>
  );
};

```
## 17.锚点平滑滚动

- 使用css的`scroll-behavior`属性
- 在**滚动条**所在的父元素中加入该属性，就可以实现锚点平滑滚动效果
```
import React, { useState } from 'react';
import style from './style.scss';

export default () => {
  const [arr] = useState([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
  return (
    <div className={style.wrap}>
      <ul className={style.ul1}>
        {arr.map((item, index) => (
          <li key={index} style={{ marginBottom: 200 }} id={`${item}`}>
            <h1>{item}</h1>
          </li>
        ))}
      </ul>
      <ul className={style.sidebar}>
        {arr.map((item, index) => (
          <li key={index}>
            <h1>
              <a href={`#${item}`}>{item}</a>
            </h1>
          </li>
        ))}
      </ul>
    </div>
  );
};

// css
.wrap {
  display: flex;
  justify-content: space-between;

  .sidebar {
    position: fixed;
    top: 0;
    right: 0;
  }

  .ul1 {
    width: 400px;
    height: 400px;
    overflow-y: scroll;
    scroll-behavior: smooth;
  }
}

```

## 18.使用dayjs替换antd组件中默认的moment
antd日期组件默认集成了momentjs这个日期处理库，这会使得打包的组件体积过大，可以使用dayjs替换antd组件中的moment

> 下载**dayjs**: `npm i datjs -S`
>
> 下载**antd-dayjs-webpack-plugin**: `npm i antd-dayjs-webpack-plugin -D`

### 1.修改webpack配置
- 参考: https://github.com/ant-design/antd-dayjs-webpack-plugin
```javascript
const AntdDayjsWebpackPlugin = require('antd-dayjs-webpack-plugin');
module.exports = {
  // ...
  plugins: [
    new AntdDayjsWebpackPlugin()
  ]
}
```
### 2.国际化
```
// ...
import { ConfigProvider } from 'antd';
import zhCN from 'antd/lib/locale/zh_CN';
import dayjs from 'dayjs';
import dayjsLocal from 'dayjs/locale/zh-cn';
// ...
// dayjs国际化
dayjs.locale(dayjsLocal)
const App = () => {
  return (
    /* antd国际化 */
    <ConfigProvider locale={zhCN}>
      <Routes />
    </ConfigProvider>
  )
};

render(<App />, document.getElementById('root'));
```
### 3. TypeScript声明修改

- 参考: https://github.com/ant-design/antd-dayjs-webpack-plugin/issues/23
> 若是使用TypeScript进行开发，还需要修改修改antd组件中默认的Moment声明，否则会报类型检测错误

- 在你项目的`xxx.d.ts`中添加以下代码
```
// global.d.ts
declare module 'moment' {
  import { Dayjs } from 'dayjs'
  namespace moment {
    type Moment = Dayjs
  }
  export = moment
  export as namespace moment
}
```

## 19.ts-node-dev
>可以实时运行TypeScript文件
- 安装 `npm install ts-node-dev -D`
```js
// package.json
"scripts": {
    "dev": "cross-env tsnd -P ./tsconfig.json --respawn ./src/index.ts",
    "build": "cross-env tsc"
  },
```
```js
// tsconfig.json
{
  "include": ["src/**/*"],
  "exclude": ["node_modules"],
  "compilerOptions": {
    "target": "ES6",
    "module": "CommonJS",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "baseUrl": "./",
    "outDir": "./dist",
    "declaration": true,
    "declarationDir": "./dist",
    "moduleResolution": "Node",
    "noImplicitAny": false,
    "downlevelIteration": true,
  }
}
```

## 20.移动端适配方案

- px vw rem

- 默认情况下 `1rem = 16px`，但为了方便换算，我们会设置 `1rem = 100px`
- 以750px的设计稿为例，则可以得出 750px = 7.5rem
- 相当于100vw=7.5rem那么1rem = 100vw / 7.5 = 13.3333vw
- 所以直接设置html的根元素为13.3333vw。若要兼容旧浏览器，则需要写入响应式布局
- 例如
```scss
// 相当于 320 / 7.5 = 42.667px
@media screen and (max-width: 320px) {
  html {
    font-size: 42.667px;
    font-size: 13.3333vw;
  }
}

// 相当于375 / 7.5 = 48px
@media screen and (min-width: 321px) and (max-width: 375px) {
  html {
    font-size: 48px;
    font-size: 13.3333vw;
  }
}

@media screen and (min-width: 376px) and (max-width:393px) {
    html {
        font-size: 52.4px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 394px) and (max-width:412px) {
    html {
        font-size: 54.93px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 413px) and (max-width:414px) {
    html {
        font-size: 55.2px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 415px) and (max-width:480px) {
    html {
        font-size: 64px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 481px) and (max-width:540px) {
    html {
        font-size: 72px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 541px) and (max-width:640px) {
    html {
        font-size: 85.33px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 641px) and (max-width:720px) {
    html {
        font-size: 96px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 721px) and (max-width:768px) {
    html {
        font-size: 102.4px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 769px) and (max-width:852px) {
    html {
        font-size: 113.4px;
        font-size: 13.3333vw
    }
}
@media screen and (min-width: 853px) {
    html {
        font-size: 130.4px;
        font-size: 13.3333vw
    }
}
```
- 而在页面样式中，直接将测量出的px除以100就是对应的rem值