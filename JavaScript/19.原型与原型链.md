## 1.原型与构造函数

讲原型离不开构造函数，构造函数的成员分为静态成员，实例成员

**实例成员：** 实例成员就是在构造函数内部，通过this添加的成员。实例成员只能通过实例化的对象来访问。

**静态成员：** 在构造函数本身上添加的成员，只能通过构造函数来访问

```js
 function Star(name,age) {
        //实例成员
        this.name = name;
        this.age = age;
    }
    //静态成员
    Star.sex = '女';

    let stars = new Star('小红',18);
    console.log(stars);      // Star {name: "小红", age: 18}
    console.log(stars.sex);  // undefined     实例无法访问sex属性

    console.log(Star.name); //Star     通过构造函数无法直接访问实例成员
    console.log(Star.sex);  //女       通过构造函数可直接访问静态成员
```

### 通过构造函数创建一个对象

```js
 function Father(name) {
     this.name = name;
 }
 let son = new Father('Lisa');
 console.log(son); //Father {name: "Lisa"}
```

### new一个对象时，内部执行机制

- 创建一个空对象
- 将这个空对象的原型对象指向构造函数的原型
- 将构造函数的this指向这个空对象并执行
- 返回这个空对象

- 手写一个`new`

```js
function myNew(...newArgs) {
    const [Fn,...arg] = newAtgs;
    // 创建一个空对象
    const obj = Object.create({});
	// 将构造函数的原型对象指向空对象的proto
	Object.setPrototypeOf(obj, Fn.prototype)
	// 将构造函数的this指向空对象并执行构造函数
	Fn.apply(obj, arg);
	// 返回这个对象
	return obj;
}
```

### 实例方法的共享问题

**方法1：在构造函数上的实例方法（不共享）**

```js
function Star() {
    this.sing = function () {
    	console.log('我爱唱歌');
	}
}
let stu1 = new Star();
let stu2 = new Star();
stu1.sing();//我爱唱歌
stu2.sing();//我爱唱歌
console.log(stu1.sing === stu2.sing);//false
```

很明显，stu1 和 stu2 指向的不是一个地方。 所以 在构造函数上通过this来添加方法的方式来生成实例，每次生成实例，都是新开辟一个内存空间存方法。这样会导致内存的极大浪费，从而影响性能

**通过原型添加的方法(共享)**

构造函数通过原型分配的函数，是所有对象共享的。

```js
function Star(name) {
    this.name = name;
}
Star.prototype.sing = function () {
    console.log('我爱唱歌', this.name);
};
let stu1 = new Star('小红');
let stu2 = new Star('小蓝');
stu1.sing();//我爱唱歌 小红
stu2.sing();//我爱唱歌 小蓝
console.log(stu1.sing === stu2.sing);//true
```

因此，原型就是为了共享一些实例方法而出现的，它本质上是一个对象

## 2.constructor

每个对象的原型上都有一个`constructor`属性，用来记录它对应的构造函数

## 3.原型链

每个对象都有`__proto__`属性，这个属性用来指向它的构造函数对应的原型

```js
function Person(){
    
}
var p = new Person()
p.__proto__ === Person.prototype // true
```

我们在使用对象上的成员时，js引擎会首先在对象本身寻找，如果找不到，就会顺着它的`__proto__`去它构造函数的原型上寻找，一直找到`Object`的`__proto__`，而它的`__proto__`指向`null`，因此，`__proto__`的路径就是原型链

## 4.练习题

### 第一题

```js
var F = function() {};

Object.prototype.a = function() {
  console.log('a');
};

Function.prototype.b = function() {
  console.log('b');
}

var f = new F();

f.a(); // a
f.b(); // error

F.a(); // a
F.b(); // b
```

### 第二题

```js
var A = function() {};
A.prototype.n = 1;
var b = new A();
A.prototype = {
  n: 2,
  m: 3
}
var c = new A();

console.log(b.n); // 1
console.log(b.m); // undefined

console.log(c.n); // 2
console.log(c.m); // 3
```

### 第三题

```js
var foo = {},
    F = function(){};
Object.prototype.a = 'value a';
Function.prototype.b = 'value b';

console.log(foo.a); // value a
console.log(foo.b); // undefined

console.log(F.a); // value a
console.log(F.b); // value b
```

### 第四题

```js
function A() {}
function B(a) {
    this.a = a; // 有实例属性时，访问会优先调用实例属性，然后调用原型上的属性
}
function C(a) {
    if (a) {
        this.a = a;
    }
}
A.prototype.a = 1;
B.prototype.a = 1;
C.prototype.a = 1;

console.log(new A().a);  // 1
console.log(new B().a); // undefined
console.log(new C(2).a); // 2
```

### 第五题

```js
console.log(123['toString'].length + 123) // 124
```

