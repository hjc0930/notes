## 1.ES5 继承

ES5中没有类的概念，通常通过声明一个构造函数来模拟类

```js
function Person(name) {
  this.name = name;
  this.sayName1 = function () {
    console.log(this.name + '在工作');
  }
}

// 原型链上的方法和属性会被多个实例共享，构造函数中的则不会
Person.prototype.sayName2 = function () {
  console.log(this.name + '在学习');
}
// 静态方法
Person.sayName3 = () => {
    console.log(this.name + '在运动')
}

var person = new Person('Tom');

person.sayName1(); // Tom在工作
person.sayName2(); // Tom在学习
```

### 继承

ES5实现继承的方式有原型链继承，构造继承，实例继承，拷贝继承，组合继承，寄生组合继承这六种

**原型链继承**

- 优点
  - 实例是子类的实例，也是父类的实例
  - 可以调用父类的实例属性和方法，也可以调用父类原型链上的属性和方法
- 缺点
  - 子类无法在构造器中新增属性或者方法，必须要在`new Person()`之后
  - 在子类实例化时，无法向父类传参
  - 父类原型对象的所有属性被所有实例共享
  - 无法实现多继承

```js
// 原型链继承
function Cat() { }
Cat.prototype = new Person('Pt'); // 只能在这里向父类传参，或者下面代码那样

var cat = new Cat();

cat.sayName1();
```

### 构造继承

- 优点
  - 解决了`原型链继承`中，子类实例共享父类引用属性的问题
  - 在创建子类实例时，可以向父类传参
  - 可以实现多继承
- 缺点
  - 实例并不是父类的实例，只是子类的实例
  - 只能继承父类构造函数中的属性和方法，不能继承父类原型链中的属性和方法
  - 无法实现函数的复用，每个子类都有父类实例函数的副本，影响性能

```js
function Cat(name) {
  Person.call(this, name);
}

var cat = new Cat('Tom');

cat.sayName1();
```

### 实例继承

- 缺点
  - 无法实现多继承
  - 子类实例化出来的对象是父类类型，不是子类类型

```js
// 实例继承
function Cat(name) {
  var instance = new Person(name);
  return instance;
}

var cat = new Cat('Tom');

cat.sayName1()
```

### 组合继承

- 优点
  - 弥补了`构造继承`的缺陷，可以继承实例的属性/方法，也可以继承原型上的属性/方法
  - 既是子类的实例，也是父类的实例
  - 可以向父类传参
  - 函数可以复用
- 缺点
  - 调用了两次父类的构造函数，生成了两份实例

```js
function Cat(name, age) {
  Person.call(this, name);
  this.age = age;
}

Cat.prototype = new Person();



var cat = new Cat('Tom', 18);

console.log(cat.name);

cat.sayName1();
cat.sayName2();

console.log(cat.age);
```

### 寄生组合继承

```js
function Cat(name) {
  Person(this, name);
}

var Temp = Object.create(Person.prototype); // 创建对象，创建父类原型的一个副本
Temp.constructor = Cat;  // 增强对象，弥补因重写原型而失去的默认的constructor 属性
Cat.prototype = Temp; // 指定对象，将新创建的对象赋值给子类的原型

var cat = new Cat('Tom');

cat.sayName1()
```



## 2.new的时候都做了什么？

- 创建一个新对象
- 把这个新对象的`__proto__`属性指向你要new 的那个对象的`prototype`
- 让构造函数里面的`this`指向新的对象，然后执行构造函数
- 返回这个新对象

## 3.ES6 Class

ES6提供了更接近传统的写法，基本上可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到

```js
class Person {
    constructor(name) {
        this.name = name;
    }
    sayName() {
        console.log(this.name + '在学习')
    }
}

const p = new Person('jiacheng')
```

构造函数上的`prototype`属性，在ES6类上面继续存在，事实上，类的所有方法都是定义在类的`prototype`属性上面的

```js
class Point {
  constructor() {
    // ...
  }

  toString() {
    // ...
  }

  toValue() {
    // ...
  }
}

// 等同于
Point.prototype = {
  constructor() {},
  toString() {},
  toValue() {},
};
```

因此，在类的实例上面调用方法，其实就是调用原型上的方法

```js
class B{}

const b = new B();

b.constructor === B.prototype.constructor // true
```

所以，使用`Object.assin()`方法可以很方便地一次向类添加多个方法

```js
class Point {
  constructor(){
    // ...
  }
}

Object.assign(Point.prototype, {
  toString(){},
  toValue(){}
});
```

`prototype`对象的`constructor()`属性，直接指向类本身，这与ES5的行为是一致的

```js
Point.prototype.constructor === Point // true
```

另外，类内部所有定义的方法，都是不可枚举的

```js
class Point {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]
```

